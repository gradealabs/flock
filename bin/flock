#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const { cli } = require('../lib/flock')

// CLI:
// flock command [lastId] [arguments]

// Commands:
// create {filename}
// migrate
// rollback
// latest

// CLI Arguments:
// (optional) --options file.js[on]

// Supported options are determined by the loaded plugin.

const HELP =
`flock {command} [lastId] [arguments]

Commands:
create {migrations/filename.js}
migrate [lastId]
rollback [lastId]
latest

Arguments:
--options file.json
--help
`

const args = process.argv.slice(2)

// If --help is present then just print the help message and exit.
if (args.find(x => x === '--help')) {
  console.log(HELP)
  process.exit(0)
}

// Handle the 'create' command
if (args[0] === 'create') {
  const fileName = args[1]

  // migration which creates a new table
  if (args.find(x => x === '--new-table')) {

    if (fileName) {
      const blah = 'asdfghjkl'

      const r = fs.createReadStream(path.resolve(__dirname, '../templates/create-table.js'))
      const w = fs.createWriteStream(path.resolve(__dirname, `../migrations/${fileName}`))
      r.pipe(w)
      r.on('end', () => {
        process.exit(0)
      })
    }
  } else {
      // NOTE: We'll need to support creating migrartions for specific plugins perhaps?

      if (fileName) {
        const r = fs.createReadStream(path.resolve(__dirname, '../templates/migration.js'))
        const w = fs.createWriteStream(fileName)
        r.pipe(w)
        r.on('end', () => {
          process.exit(0)
        })
      } else {
        throw new Error('Create command requires a migration file name.')
      }
  }
 
// Handle all other commands (i.e. pass them to flock)
} else {
  // Handle the --options argument
  const optionsModuleId = args.find(x => x === '--options')
    ? args[args.indexOf('--options') + 1]
    : false
  // Load the options file as a Node module
  const options = optionsModuleId
    ? require(optionsModuleId)
    : {}
  // NOTE: To support other plugins (i.e. DB drivers) we will need to handle the
  // argument --plugin {name}.
  const pluginName = 'pg'
  // NOTE: Will likely have to support a top-level and relative module IDs and
  // be able to handle loading plugins provided by this module and external
  // plugins.
  const pluginModuleId = pluginName.startsWith('.')
    ? pluginName
    : `../lib/${pluginName}/plugin`
  // Load the plugin as a Node module
  const { plugin } = require(pluginModuleId) || null

  if (typeof plugin !== 'function') {
    throw new Error(`Plugin ${pluginModuleId} does not export a "plugin" funciton.`)
  }

  new Promise(resolve => {
    resolve(plugin(options))
  }).then(({ migrator, context }) => {
    return cli(migrator, context, args)
  }).catch(error => {
    console.error(error)
  })
}
